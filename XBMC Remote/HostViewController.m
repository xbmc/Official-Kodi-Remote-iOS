//
//  HostViewController.m
//  XBMC Remote
//
//  Created by Giovanni Messina on 14/4/12.
//  Copyright (c) 2012 joethefox inc. All rights reserved.
//

#import "HostViewController.h"
#import "AppDelegate.h"
#include <arpa/inet.h>

#if TARGET_OS_IOS && !TARGET_OS_SIMULATOR
// Remove code for resolving MAC address from iOS as anyway not supported
#define RESOLVE_MAC_ADDRESS 0
#else
// Support resolving MAC address on non-iOS OS
#define RESOLVE_MAC_ADDRESS 1
#endif

#if (RESOLVE_MAC_ADDRESS)
#import "route.h"
#import "if_ether.h"
#endif

#import <sys/socket.h>
#import <sys/sysctl.h>
#import <ifaddrs.h>
#import <net/if_dl.h>
#import <net/if.h>
#import <netinet/in.h>
#import "Utilities.h"

#define serviceTypeHTTP @"_xbmc-jsonrpc-h._tcp"
#define serviceTypeTCP @"_xbmc-jsonrpc._tcp"
#define domainName @"local"
#define DISCOVER_TIMEOUT 15.0
#define BUFLEN (sizeof(struct rt_msghdr) + 512)
#define SEQ 9999
#define RTM_VERSION	5           // important, version 2 does not return a mac address!
#define RTM_GET	0x4             // Report Metrics
#define RTF_LLINFO	0x400       // generated by link layer (e.g. ARP)
#define RTF_IFSCOPE 0x1000000   // has valid interface scope
#define RTA_DST	0x1             // destination sockaddr present
#define IPAD_POPOVER_WIDTH 400
#define IPAD_POPOVER_HEIGHT 500

#define XIB_PASSWORD_FIELD 12
#define XIB_FIRST_MAC_ADDRESS_FIELD 5
#define XIB_LAST_MAC_ADDRESS_FIELD 10


@implementation HostViewController

- (id)initWithNibName:(NSString*)nibNameOrNil bundle:(NSBundle*)nibBundleOrNil {
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    return self;
}

- (void)configureView {
    if (self.detailItem == nil) {
        self.navigationItem.title = LOCALIZED_STR(@"New XBMC Server");
    }
    else {
        self.navigationItem.title = LOCALIZED_STR(@"Modify XBMC Server");
        NSIndexPath *idx = self.detailItem;
        NSDictionary *item = AppDelegate.instance.arrayServerList[idx.row];
        descriptionUI.text = item[@"serverDescription"];
        usernameUI.text = item[@"serverUser"];
        passwordUI.text = item[@"serverPass"];
        ipUI.text = item[@"serverIP"];
        portUI.text = item[@"serverPort"];
        NSString *macAddress = item[@"serverMacAddress"];
        NSArray *macPart = [macAddress componentsSeparatedByString:@":"];
        if (macPart.count == 6) {
            mac_0_UI.text = macPart[0];
            mac_1_UI.text = macPart[1];
            mac_2_UI.text = macPart[2];
            mac_3_UI.text = macPart[3];
            mac_4_UI.text = macPart[4];
            mac_5_UI.text = macPart[5];
        }
        tcpPortUI.text = item[@"tcpPort"];
    }
}

- (IBAction)dismissView:(id)sender {
    
    [self textFieldDoneEditing:nil];
    
    for (UITextField *textfield in [self getAllEntryMaskLabels]) {
        textfield.text = textfield.text ?: @"";
    }
    
    NSString *macAddress = [NSString stringWithFormat:@"%@:%@:%@:%@:%@:%@", mac_0_UI.text, mac_1_UI.text, mac_2_UI.text, mac_3_UI.text, mac_4_UI.text, mac_5_UI.text];
    
    NSDictionary *serverParameters = @{
        @"serverDescription": descriptionUI.text,
        @"serverUser": usernameUI.text,
        @"serverPass": passwordUI.text,
        @"serverIP": ipUI.text,
        @"serverPort": portUI.text,
        @"serverMacAddress": macAddress,
        @"tcpPort": tcpPortUI.text,
    };
    if (self.detailItem == nil) {
        [AppDelegate.instance.arrayServerList addObject:serverParameters];
    }
    else {
        NSIndexPath *idx = self.detailItem;
        [AppDelegate.instance.arrayServerList removeObjectAtIndex:idx.row];
        [AppDelegate.instance.arrayServerList insertObject:serverParameters atIndex:idx.row];
    }
    [AppDelegate.instance saveServerList];
    [self.navigationController popViewControllerAnimated:YES];
}

#pragma mark - Helper

- (void)tailorViewContent:(BOOL)isEditing {
    if (isEditing) {
        if (IS_IPAD && IS_LANDSCAPE) {
            tipView.hidden = YES;
        }
        else {
            tipView.hidden = NO;
        }
    }
    else {
        tipView.hidden = NO;
    }
}

- (NSArray*)getAllEntryMaskLabels {
    NSArray *allEntryMaskLabels = @[
        descriptionUI,
        ipUI,
        portUI,
        tcpPortUI,
        usernameUI,
        passwordUI,
        mac_0_UI,
        mac_1_UI,
        mac_2_UI,
        mac_3_UI,
        mac_4_UI,
        mac_5_UI,
    ];
    return allEntryMaskLabels;
}

#pragma mark - UITextFieldDelegate Methods

- (void)textFieldDidBeginEditing:(UITextField*)textField {
    textField.textColor = [Utilities get1stLabelColor];
    [self tailorViewContent:YES];
}

- (void)resignKeyboard {
    [descriptionUI resignFirstResponder];
    [ipUI resignFirstResponder];
    [portUI resignFirstResponder];
    [tcpPortUI resignFirstResponder];
    [usernameUI resignFirstResponder];
    [mac_0_UI resignFirstResponder];
    [mac_1_UI resignFirstResponder];
    [mac_2_UI resignFirstResponder];
    [mac_3_UI resignFirstResponder];
    [mac_4_UI resignFirstResponder];
    [mac_5_UI resignFirstResponder];
    [passwordUI resignFirstResponder];
    [self tailorViewContent:NO];
}

- (BOOL)textFieldShouldReturn:(UITextField*)theTextField {
    if (theTextField.tag < XIB_PASSWORD_FIELD) {
        UITextField *next = (UITextField*)[self.view viewWithTag:theTextField.tag + 1];
        [next becomeFirstResponder];
        //[next selectAll:self];
        return NO;
    }
    else {
        [self resignKeyboard];
        [theTextField resignFirstResponder];
        return YES;
    }
}

- (IBAction)textFieldDoneEditing:(id)sender {
    [self resignKeyboard];
}

- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string {
    NSUInteger newLength = textField.text.length + string.length - range.length;
    return !(newLength > 2 && textField.tag >= XIB_FIRST_MAC_ADDRESS_FIELD && textField.tag <= XIB_LAST_MAC_ADDRESS_FIELD);
}

# pragma mark - Gestures

- (void)handleSwipeFromRight:(id)sender {
    [self.navigationController popViewControllerAnimated:YES];
}


# pragma mark - NSNetServiceBrowserDelegate Methods

- (void)netServiceBrowserWillSearch:(NSNetServiceBrowser*)browser {
    searching = YES;
    [self updateUI];
}

- (void)netServiceBrowserDidStopSearch:(NSNetServiceBrowser*)browser {
    searching = NO;
    [self updateUI];
}

- (void)netServiceBrowser:(NSNetServiceBrowser*)browser didNotSearch:(NSDictionary*)errorDict {
    searching = NO;
    [self handleError:errorDict[NSNetServicesErrorCode]];
    [activityIndicatorView stopAnimating];
    startDiscover.enabled = YES;
}

- (void)netServiceBrowser:(NSNetServiceBrowser*)browser
           didFindService:(NSNetService*)aNetService
               moreComing:(BOOL)moreComing {
    NSString *type = aNetService.type;
    NSString *name = aNetService.name;
    NSLog(@"Found '%@', '%@'", name, type);
    if ([type containsString:serviceTypeHTTP]) {
        [services addObject:aNetService];
        if (!moreComing) {
            [self stopDiscovery];
        }
    }
    else if ([name isEqualToString:descriptionUI.text]) {
        // Trigger [service resolveWithTimeout:0] to have netServiceDidResolveAddress called which reads the TCP port
        [self resolveIPAddress:aNetService];
    }
}

- (void)netServiceBrowser:(NSNetServiceBrowser*)browser
         didRemoveService:(NSNetService*)aNetService
               moreComing:(BOOL)moreComing {
    NSString *type = aNetService.type;
    if ([type containsString:serviceTypeHTTP]) {
        [services removeObject:aNetService];
    }
    if (!moreComing) {
        [self updateUI];
    }
}

- (void)handleError:(NSNumber*)error {
    // Handle error here
}

- (void)updateUI {
    if (!searching) {
        NSInteger j = services.count;
        if (j == 1) {
            [self resolveIPAddress:services[0]];
        }
        else {
            if (j == 0) {
                [Utilities AnimView:noInstances AnimDuration:0.3 Alpha:1.0 XPos:0];
            }
            else {
                [discoveredInstancesTableView reloadData];
                [Utilities AnimView:discoveredInstancesView AnimDuration:0.3 Alpha:1.0 XPos:0];
            }
        }
    }
}

#pragma mark - resolveMacAddress Methods

#if (RESOLVE_MAC_ADDRESS)
- (NSString*)resolveMacFromIP:(NSString*)ipAddress {
    NSString *res = nil;
    
    in_addr_t host = inet_addr([ipAddress UTF8String]);
    int sockfd;
    unsigned char buf[BUFLEN];
    unsigned char buf2[BUFLEN];
    ssize_t n;
    struct rt_msghdr *rtm;
    struct sockaddr_in *sin;
    
    memset(buf, 0, sizeof(buf));
    memset(buf2, 0, sizeof(buf2));
    
    sockfd = socket(AF_ROUTE, SOCK_RAW, 0);
    rtm = (struct rt_msghdr*)buf;
    rtm->rtm_msglen = sizeof(struct rt_msghdr) + sizeof(struct sockaddr_in);
    rtm->rtm_version = RTM_VERSION;
    rtm->rtm_type = RTM_GET;
    rtm->rtm_addrs = RTA_DST;
    rtm->rtm_flags = RTF_LLINFO;
    rtm->rtm_pid = 1234;
    rtm->rtm_seq = SEQ;
    
    sin = (struct sockaddr_in*)(rtm + 1);
    sin->sin_len = sizeof(struct sockaddr_in);
    sin->sin_family = AF_INET;
    sin->sin_addr.s_addr = host;
    write(sockfd, rtm, rtm->rtm_msglen);
    
    n = read(sockfd, buf2, BUFLEN);
    if (n != 0) {
        int index = sizeof(struct rt_msghdr) + sizeof(struct sockaddr_inarp) + 8;
        res = [NSString stringWithFormat:@"%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
               buf2[index + 0], buf2[index + 1], buf2[index + 2], buf2[index + 3], buf2[index + 4], buf2[index + 5]];
    }
    
    return res;
}

- (void)fillMacAddressInfo:(NSString*)ipAddress {
    NSString *macAddress = [self resolveMacFromIP:ipAddress];
    NSArray *macPart = [macAddress componentsSeparatedByString:@":"];
    // Both 02:... and 00:... are invalid addresses (first seen on target, second on simulator)
    if (macPart.count == 6 &&
        ![macAddress isEqualToString:@"02:00:00:00:00:00"] &&
        ![macAddress isEqualToString:@"00:00:00:00:00:00"]) {
        NSArray *macLabels = @[
            mac_0_UI,
            mac_1_UI,
            mac_2_UI,
            mac_3_UI,
            mac_4_UI,
            mac_5_UI,
        ];
        [macLabels enumerateObjectsUsingBlock:^(UILabel *label, NSUInteger idx, BOOL *stop) {
            label.text = macPart[idx];
            label.textColor = [Utilities getSystemBlue];
        }];
    }
}
#endif

- (void)fillAddressPort:(NSMutableDictionary*)serverAddresses port:(int)httpPort addr:(NSString*)addr name:(NSString*)name ip:(NSString*)ipversion {
    if (httpPort > 0) {
        NSString *port = [NSString stringWithFormat:@"%d", httpPort];
        serverAddresses[@"hostname"] = @{
            @"addr": name,
            @"port": port,
        };
        if (addr.length) {
            serverAddresses[ipversion] = @{
                @"addr": addr,
                @"port": port,
            };
        }
    }
}

- (void)fillTcpPort:(NSMutableDictionary*)serverAddresses port:(int)tcpPort ip:(NSString*)ipversion {
    if (tcpPort > 0) {
        NSString *port = [NSString stringWithFormat:@"%d", tcpPort];
        NSMutableDictionary *server = [serverAddresses[@"hostname"] mutableCopy];
        server[@"tcpport"] = port;
        serverAddresses[@"hostname"] = server;
        
        server = [serverAddresses[ipversion] mutableCopy];
        server[@"tcpport"] = port;
        serverAddresses[ipversion] = server;
    }
}

# pragma mark - resolveIPAddress Methods

- (void)resolveIPAddress:(NSNetService*)service {
    remoteService = service;
    remoteService.delegate = self;
    [remoteService resolveWithTimeout:0];
}

- (void)netServiceDidResolveAddress:(NSNetService*)service {
    NSString *type = service.type;
    if ([type containsString:serviceTypeHTTP]) {
        serverAddresses = [NSMutableDictionary new];
        serverAddresses[@"serverName"] = service.name;
        for (NSData *data in [service addresses]) {
            char addressBuffer[MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN)];
            struct sockaddr_in *socketAddress = (struct sockaddr_in*)[data bytes];
            int sockFamily = socketAddress->sin_family;
            if (sockFamily == AF_INET) {
                const char *addressStr = inet_ntop(sockFamily,
                                                   &(socketAddress->sin_addr),
                                                   addressBuffer,
                                                   INET_ADDRSTRLEN);
                NSString *addr = addressStr ? @(addressStr) : @"";
                [self fillAddressPort:serverAddresses port:ntohs(socketAddress->sin_port) addr:addr name:service.hostName ip:@"ipv4"];
            }
            else if (sockFamily == AF_INET6) {
                const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)[data bytes];
                const char *addressStr = inet_ntop(AF_INET6,
                                                   &addr6->sin6_addr,
                                                   addressBuffer,
                                                   INET6_ADDRSTRLEN);
                NSString *addr = addressStr ? @(addressStr) : @"";
                [self fillAddressPort:serverAddresses port:ntohs(addr6->sin6_port) addr:addr name:service.hostName ip:@"ipv6"];
            }
        }
        NSLog(@"Resolved address/port for service '%@' by '%@': %@", type, service.name, serverAddresses);
        
#if (RESOLVE_MAC_ADDRESS)
        if (serverAddresses[@"ipv4"]) {
            // Ping server and resolve MAC address. Only works with IPv4 address.
            NSDictionary *server = serverAddresses[@"ipv4"];
            NSString *serverJSON = [NSString stringWithFormat:@"http://%@:%@/jsonrpc", server[@"addr"], server[@"port"]];
            NSURL *url = [[NSURL alloc] initWithString:serverJSON];
            NSURLSession *pingSession = [NSURLSession sharedSession];
            NSURLSessionDataTask *pingConnection = [pingSession dataTaskWithURL:url
                                                              completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self fillMacAddressInfo:server[@"addr"]];
                });
            }];
            [pingConnection resume];
        }
#endif
        // Show discovered instances view (for multiple instances) and trigger the TCP port discovery
        if (serverAddresses.count) {
            [Utilities AnimView:discoveredInstancesView AnimDuration:0.3 Alpha:1.0 XPos:self.view.frame.size.width];
            
            // Trigger search for TCP service
            [netServiceBrowser searchForServicesOfType:serviceTypeTCP inDomain:domainName];
            timer = [NSTimer scheduledTimerWithTimeInterval:DISCOVER_TIMEOUT target:self selector:@selector(stopDiscovery) userInfo:nil repeats:NO];
        }
    }
    else {
        for (NSData *data in [service addresses]) {
            struct sockaddr_in *socketAddress = (struct sockaddr_in*)[data bytes];
            int sockFamily = socketAddress->sin_family;
            if (sockFamily == AF_INET) {
                [self fillTcpPort:serverAddresses port:ntohs(socketAddress->sin_port) ip:@"ipv4"];
            }
            else if (sockFamily == AF_INET6) {
                const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)[data bytes];
                [self fillTcpPort:serverAddresses port:ntohs(addr6->sin6_port) ip:@"ipv6"];
            }
        }
        NSLog(@"TCP port for '%@': %@", service.name, serverAddresses[@"hostname"][@"tcpport"]);
    }
    
    [self fillServerDetailsForSegment:segmentServerType.selectedSegmentIndex];
}

- (void)stopDiscovery {
    [timer invalidate];
    [netServiceBrowser stop];
    [activityIndicatorView stopAnimating];
    startDiscover.enabled = YES;
}

- (IBAction)startDiscover:(id)sender {
    [self resignKeyboard];
    [netServiceBrowser stop];
    [activityIndicatorView startAnimating];
    [services removeAllObjects];
    startDiscover.enabled = NO;
    [Utilities AnimView:noInstances AnimDuration:0.3 Alpha:0.0 XPos:self.view.frame.size.width];
    [Utilities AnimView:discoveredInstancesView AnimDuration:0.3 Alpha:1.0 XPos:self.view.frame.size.width];

    searching = NO;
    netServiceBrowser.delegate = self;
    [netServiceBrowser searchForServicesOfType:serviceTypeHTTP inDomain:domainName];
    timer = [NSTimer scheduledTimerWithTimeInterval:DISCOVER_TIMEOUT target:self selector:@selector(stopDiscovery) userInfo:nil repeats:NO];
}

#pragma mark - Segment control

- (void)segmentValueChanged:(UISegmentedControl*)segment {
    [self fillServerDetailsForSegment:segment.selectedSegmentIndex];
}

- (void)fillServerDetailsForSegment:(long)activeSegment {
    NSArray *segmentModes = @[@"ipv4", @"ipv6", @"hostname"];
    long index = activeSegment < segmentModes.count ? activeSegment : 0;
    NSString *mode = segmentModes[index];
    NSDictionary *server = serverAddresses[mode];
    
    // Set values for UI and persistency
    descriptionUI.text = serverAddresses[@"serverName"];
    ipUI.text = server[@"addr"];
    portUI.text = server[@"port"];
    descriptionUI.textColor = [Utilities getSystemBlue];
    ipUI.textColor = [Utilities getSystemBlue];
    portUI.textColor = [Utilities getSystemBlue];
    
    // Set values for UI and persistency
    tcpPortUI.text = server[@"tcpport"];
    tcpPortUI.textColor = [Utilities getSystemBlue];
}

#pragma mark - Help URLs

- (IBAction)openHelpWiki:(id)sender {
    [Utilities SFloadURL:@"https://kodi.wiki/view/Smartphone/tablet_remotes" fromctrl:self];
}

- (IBAction)openHelpForum:(id)sender {
    [Utilities SFloadURL:@"https://forum.kodi.tv/showthread.php?tid=372379" fromctrl:self];
}

#pragma mark - TableViewDelegate

- (NSInteger)numberOfSectionsInTableView:(UITableView*)tableView {
	return 1;
}


- (NSInteger)tableView:(UITableView*)tableView numberOfRowsInSection:(NSInteger)section {
	return services.count;
}


- (UITableViewCell*)tableView:(UITableView*)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath {
	static NSString *tableCellIdentifier = @"UITableViewCell";
	UITableViewCell *cell = (UITableViewCell*)[tableView dequeueReusableCellWithIdentifier:tableCellIdentifier];
	if (cell == nil) {
		cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:tableCellIdentifier];
	}
	
	NSUInteger count = services.count;
	if (count == 0) {
		return cell;
	}
    NSNetService *service = services[indexPath.row];
	cell.textLabel.text = service.name;
	cell.textLabel.textColor = [Utilities get1stLabelColor];
	cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;
	return cell;
}

- (void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath {
    if (services.count == 0) {
        return;
    }
    [self resolveIPAddress:services[indexPath.row]];
}

#pragma mark - LifeCycle

- (void)viewWillAppear:(BOOL)animated {
    CGSize size = CGSizeMake(IPAD_POPOVER_WIDTH, IPAD_POPOVER_HEIGHT);
    self.preferredContentSize = size;
    [super viewWillAppear:animated];
    [self configureView];
}

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    services = [NSMutableArray new];
    netServiceBrowser = [NSNetServiceBrowser new];
}

- (void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];
    [timer invalidate];
    netServiceBrowser = nil;
    services = nil;
    [Utilities AnimView:discoveredInstancesView AnimDuration:0.0 Alpha:1.0 XPos:self.view.frame.size.width];
    for (UITextField *textfield in [self getAllEntryMaskLabels]) {
        textfield.text = @"";
        textfield.textColor = [Utilities get1stLabelColor];
    }
    [Utilities AnimView:noInstances AnimDuration:0.0 Alpha:0.0 XPos:self.view.frame.size.width];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    descriptionLabel.text = LOCALIZED_STR(@"Description");
    hostLabel.text = LOCALIZED_STR(@"Host : port /\nTCP port");
    macLabel.text = LOCALIZED_STR(@"MAC Address");
    userLabel.text = LOCALIZED_STR(@"Username and Password");
    preferenceLabel.text = LOCALIZED_STR(@"Preference");
    noInstancesLabel.text = LOCALIZED_STR(@"No XBMC instances were found :(");
    findLabel.text = LOCALIZED_STR(@"\"Find XBMC\" requires XBMC server option\n\"Announce these services to other systems via Zeroconf\" enabled");
    howtoLabel.text = LOCALIZED_STR(@"How-to activate the remote app in Kodi");
    howtoLaterLabel.text = LOCALIZED_STR(@"Settings > Services > Control:\n1. Web Server > Allow remote control via HTTP\n2. Application Control > Allow remote control from applications on other systems");
    
    [saveButton setTitle:LOCALIZED_STR(@"Save") forState:UIControlStateNormal];
    [startDiscover setTitle:LOCALIZED_STR(@"Find XBMC") forState:UIControlStateNormal];
    startDiscover.titleLabel.numberOfLines = 1;
    startDiscover.titleLabel.adjustsFontSizeToFitWidth = YES;
    startDiscover.titleLabel.lineBreakMode = NSLineBreakByClipping;
    
    UIImage *img = [UIImage imageNamed:@"button_find"];
    img = [Utilities colorizeImage:img withColor:[Utilities getSystemBlue]];
    [saveButton setBackgroundImage:img forState:UIControlStateNormal];
    [startDiscover setBackgroundImage:img forState:UIControlStateNormal];
    
    descriptionUI.placeholder = LOCALIZED_STR(@"e.g. My XBMC");
    ipUI.placeholder = LOCALIZED_STR(@"e.g. 192.168.0.8");
    usernameUI.placeholder = LOCALIZED_STR(@"Username");
    passwordUI.placeholder = LOCALIZED_STR(@"Password");
    self.edgesForExtendedLayout = 0;
    
    for (UITextField *textfield in [self getAllEntryMaskLabels]) {
        textfield.layer.borderColor = UIColor.lightGrayColor.CGColor;
        textfield.layer.borderWidth = 1.0 / UIScreen.mainScreen.scale;
        textfield.backgroundColor = [Utilities getSystemGray6];
        textfield.tintColor = [Utilities get1stLabelColor];
    }
    discoveredInstancesTableView.backgroundColor = [Utilities getSystemGray6];
    UISwipeGestureRecognizer *rightSwipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipeFromRight:)];
    rightSwipe.numberOfTouchesRequired = 1;
    rightSwipe.cancelsTouchesInView = NO;
    rightSwipe.direction = UISwipeGestureRecognizerDirectionRight;
    [self.view addGestureRecognizer:rightSwipe];
    
    CGFloat bottomPadding = [Utilities getBottomPadding];
    if (IS_IPAD) {
        bottomPadding = SERVERPOPUP_BOTTOMPADDING;
    }
    if (bottomPadding > 0) {
        CGRect frame = tipView.frame;
        frame.origin.y -= bottomPadding;
        tipView.frame = frame;
    }
    
    // We use white fonts for the segment control
    [segmentServerType setTitleTextAttributes:@{NSForegroundColorAttributeName : UIColor.whiteColor} forState:UIControlStateNormal];
    [segmentServerType setTitleTextAttributes:@{NSForegroundColorAttributeName : UIColor.whiteColor} forState:UIControlStateHighlighted];
    [segmentServerType setTitleTextAttributes:@{NSForegroundColorAttributeName : UIColor.whiteColor} forState:UIControlStateSelected];
    
    // Set segment control text for "host name" mode
    [segmentServerType setTitle:LOCALIZED_STR(@"Host name") forSegmentAtIndex:2];
    
    [segmentServerType addTarget:self action:@selector(segmentValueChanged:) forControlEvents: UIControlEventValueChanged];
}

- (BOOL)shouldAutorotate {
    return YES;
}

@end
